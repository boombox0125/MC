/********************************************************************
 * Minimal WebGL Minecraft clone (Three.js r128)
 * Author: You
 *******************************************************************/
const scene    = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);
scene.fog        = new THREE.Fog(0x87CEEB, 50, 200);

const camera = new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,1000);
camera.position.set(0, 10, 10);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

/* lights */
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const sun = new THREE.DirectionalLight(0xffffff, 0.8);
sun.position.set(50, 100, 50); sun.castShadow = true;
sun.shadow.camera.set(-50,50,50,-50,0.1,200);
scene.add(sun);

/* materials */
const mat = {
  grass : new THREE.MeshLambertMaterial({color:0x7CFC00}),
  dirt  : new THREE.MeshLambertMaterial({color:0x8B4513}),
  stone : new THREE.MeshLambertMaterial({color:0x808080}),
  wood  : new THREE.MeshLambertMaterial({color:0xA0522D})
};
const blockTypes = ['grass','dirt','stone','wood'];
let selected     = 'grass';

/* world */
const world = new Map();
const geo   = new THREE.BoxGeometry(1,1,1);
const group = new THREE.Group(); scene.add(group);

function key(x,y,z){return `${x}|${y}|${z}`;}

function addBlock(x,y,z,type){
  if(world.has(key(x,y,z)))return;
  const mesh = new THREE.Mesh(geo, mat[type]||mat.grass);
  mesh.position.set(x,y,z);
  mesh.castShadow = mesh.receiveShadow = true;
  mesh.userData={x,y,z,type};
  group.add(mesh);
  world.set(key(x,y,z),mesh);
  updateCounter();
}
function removeBlock(x,y,z){
  const k=key(x,y,z);
  if(!world.has(k))return;
  group.remove(world.get(k));
  world.delete(k);
  updateCounter();
}

/* terrain */
const RANGE=20;
for(let x=-RANGE;x<=RANGE;x++){
  for(let z=-RANGE;z<=RANGE;z++){
    const h = Math.floor(Math.random()*3)+1;
    addBlock(x,h,z,'grass');
    for(let y=h-1;y>0;y--)addBlock(x,y,z,'dirt');
    addBlock(x,0,z,'stone');
  }
}

/* player */
const vel=new THREE.Vector3(), speed=0.15, jumpV=0.2;
let pitch=0,yaw=0,grounded=false;
const keys={};

document.addEventListener('keydown',e=>{
  keys[e.key.toLowerCase()]=true;
  const n=parseInt(e.key);
  if(n>=1&&n<=4){selected=blockTypes[n-1];selectedBlock.textContent=selected;}
});
document.addEventListener('keyup',e=>keys[e.key.toLowerCase()]=false);

renderer.domElement.addEventListener('click',()=>renderer.domElement.requestPointerLock());
document.addEventListener('pointerlockchange',()=>{
  if(document.pointerLockElement===renderer.domElement)
       document.addEventListener('mousemove',mouseLook);
  else document.removeEventListener('mousemove',mouseLook);
});
function mouseLook(e){
  yaw  -= e.movementX*0.002;
  pitch-= e.movementY*0.002;
  pitch=Math.max(-Math.PI/2,Math.min(Math.PI/2,pitch));
}
renderer.domElement.addEventListener('contextmenu',e=>e.preventDefault());

/* raycast interaction */
const ray=new THREE.Raycaster();
renderer.domElement.addEventListener('mousedown',e=>{
  if(document.pointerLockElement!==renderer.domElement)return;
  const dir=new THREE.Vector3(); camera.getWorldDirection(dir);
  ray.set(camera.position,dir);
  const hits=ray.intersectObjects(group.children);
  if(!hits.length)return;
  const{b,x,y,z}=hits[0].object.userData;
  if(e.button===0)removeBlock(x,y,z);
  else{
     const{n}=hits[0].face;
     addBlock(x+n.x,y+n.y,z+n.z,selected);
  }
});

/* physics & loop */
function update(){
  requestAnimationFrame(update);

  /* movement */
  const fwd=new THREE.Vector3(), right=new THREE.Vector3();
  camera.getWorldDirection(fwd); fwd.y=0; fwd.normalize();
  right.crossVectors(fwd,new THREE.Vector3(0,1,0));

  const move=new THREE.Vector3();
  if(keys['w'])move.add(fwd);
  if(keys['s'])move.sub(fwd);
  if(keys['a'])move.sub(right);
  if(keys['d'])move.add(right);
  move.normalize().multiplyScalar(speed);

  vel.y-=0.01; // gravity
  if(keys[' ']&&grounded)vel.y=jumpV;

  vel.x=move.x; vel.z=move.z;
  const next=camera.position.clone().add(vel);
  /* crude AABB collision */
  const wouldHit=world.has(key(Math.floor(next.x),Math.floor(next.y-1),Math.floor(next.z));
  if(!wouldHit)camera.position.copy(next);else vel.y=0;
  grounded=world.has(key(Math.floor(camera.x),Math.floor(camera.y-1.8),Math.floor(camera.z)));

  camera.rotation.set(pitch,yaw,0,'YXZ');
  renderer.render(scene,camera);
}
function updateCounter(){blockCount.textContent=world.size;}

/* start */
update();
addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});